
# Development Common sense

 - [절차적 프로그래밍](#절차적-프로그래밍)
 - [객체 지향 프로그래밍](#객체-지향-프로그래밍)
 - [RESTful API](#RESTful-API)
 - [테스트 주도 개발 (TDD)](#테스트-주도-개발-(TDD))

</br>
</br>

## 절차적 프로그래밍

### 절차적 프로그래밍이란?

**절차적 프로그래밍**(PP : Procedural Programming)이란 컴퓨터 프로그래밍 패러다임 중 하나로, <u>단순히 순차적인 명령 수행이 아니라 루틴, 서브루틴, 메소드, 함수 등(통틀어 **프로시저**)을 이용한 프로그래밍 방법</U>이다.

</br>

### PP 장점

1. 개인 프로젝트에 적합하다.
2. 객체 지향 프로그래밍과 비교하여 속도가 빠른 편이다.

</br>

### PP 단점

1. 유지보수가 어렵습니다.
2. 코드의 순서가 바뀌면 결과값을 도출하기 어렵다.
3. 프로그램의 분석과 디버깅이 어렵다.
4. 대형 프로젝트에 부적합하다.

</br>

### PP 특징

1. 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 **Top-Down 방식**으로 설계된다.
2. 비교적 작은 규모의 작업을 수행하는 함수(function)를 생성한다.
3. 인수(parameter)와 반환값(value)으로 명령을 전달하고 수행한다.
4. 객체 지향 프로그래밍과의 가장 큰 차이점으로 데이터와 함수를 별개로 취급한다.
5. 특정 기능을 수행하려면 그 일을 해주는 메소드를 직접 호출해야 한다,
   
   객체 지향 프로그래밍에서는 특정 기능을 수행하는 메소드를 가진 객체를 만들어서 그 객체를 이용해 메소드를 호출한다.

</br>


### Referencing and Citation
- [절차적 프로그래밍](https://velog.io/@pneuma/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [절차지향](http://www.incodom.kr/%EC%A0%88%EC%B0%A8_%EC%A7%80%ED%96%A5)

---
</br>

## 객체 지향 프로그래밍

### 객체 지향 프로그래밍이란?

**객체 지향 프로그래밍**(OOP : Object Oriented Programming)이란 컴퓨터 프로그래밍 패러다임 중 하나로, <u>프로그래밍에서 필요한 데이터를 **추상화**시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법</u>이다.

**인간 중심적** 프로그래밍 패러다임이며, 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 어플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다.

</br>

### OOP 장점

1. 코드 재사용이 용이하다.

   자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보할 수 있다. 또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다. (상속/확장)

2. 유지보수가 쉽다.

   절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면, 객체 지향 프로그램에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 된다.

3. 대형 프로젝트에 적합하다. 
 
   클래스 단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기가 쉽다.

</br>

### OOP 단점

1. 처리속도가 상대적으로 느리다.
2. 객체가 많으면 용량이 커질 수 있다.
3. 설계 시 많은 시간과 노력이 필요하다.

</br>

### OOP 중요 키워드

1. 클래스 + 인스턴스(객체)
   
   **클래스** : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 **추상화**를 거쳐 <u>집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 **변수**와 **메서드**로 정의한 것</u>  
   **인스턴스(객체)** : <u>클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것</u>으로 실제 프로그램에서 사용되는 **데이터**

2. 추상화
   
   **추상화**란 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 <u>공통의 속성이나 기능을 묶어 이름을 붙이는 것</u>이다.   
   (멤버변수를 private로 선언하고 getter와 setter를 통해 접근하는 것)

3. 캡슐화
   
    **캡슐화**란 객체 지향 프로그래밍에서 <u>기능과 특성의 모음을 **클래스**라는 **캡슐**에 분류해서 넣는것</u>이다.  
    객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.  
    캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활하다.  
    **캡술화의 목적 : 코드를 재수정 없이 재활용 하는 것.**

4. 상속  
   
    **상속**이란 <u>부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는것</u>이다.

5. 다형성  
   
    **다형성**이란 <u>하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것</u>이다.  
    **오버라이딩** (Overriding) : 부모 클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것  
    **오버로딩** (Overloading) : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것

</br>


### 객체 지향적 설계 원칙 (SOLID)

1. SRP(Single Responsibility Principle) : 단일 책임 원칙

    클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.

2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙

    확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙

    상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

    인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
   
    고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

</br>

### Referencing and Citation
- [객체 지향 프로그래밍이 뭔가요?](https://jeong-pro.tistory.com/95)
- [객체 지향에 대한 이해 / 객체 지향적 설계](https://asfirstalways.tistory.com/177)

---
</br>

## RESTful API

### RESTful API란?

**REST API**(RESTful API, 레스트풀 API)란 <u>월드 와이드 웹(WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍쳐의 한 형식</u>이다.

**REST**는 <u>REpresentational State Transfer</u>의 약자이다. 여기에 ~ful 이라는 형용사형 어미를 붙여 ~한 API라는 표현으로 사용된다. 즉, REST의 기본 원칙을 지킨 서비스 디자인은 'RESTful'하다고 할 수 있다.

**API**(Application Programming Interface)는 <u>어플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트</u>이다.

</br>

### REST의 구성

 - **자원(RESOURCE)** - URI
 - **행위(Verb)** - HTTP METHOD
 - **표현(Representations)**

</br>

### REST의 특징

1. Uniform (유니폼 인터페이스)

    Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.

2. Stateless (무상태성)

    REST는 무상태성 성격을 가지고 있다. 무상태성 성격이란 작업을 위한 상태정보를 따로 저장하고 관리하지 않는 것이다. 세션 정보나 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 된다. 이 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다.

3. Cacheable (캐시 가능)

    REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능하다. HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.

4. Self-descriptiveness (자체 표현 구조)

    REST의 토 따른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것이다.

5. Client - Sever 구조

    REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 된다.

6. 계층형 구조

    REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 한다.

</br>

### RESTful 하게 API를 디자인 한다는 것

1. **자원**(Resource)과 **행위**(Verb)를 명시적이고 직관적으로 분리한다.
   
   * **자원**은 <u>URI</u>로 표현되는데 리소스가 가리키는 것은 <u>명사</u>로 표현되어야 한다.
   * **행위**는 <u>HTTP Method</u>로 표현하고 <u>GET(조회), POST(생성), PUT(기존 entity 전체 수정), PATCH(기존 entity 일부 수정), DELETE(삭제)</u>를 분명한 목적으로 사용한다.

2. Message는 Header와 Body를 명확하게 분리해서 사용한다.
   
   * <u>Entity에 대한 내용</u>은 <u>body</u>에 담는다.
   * <u>어플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보</u>인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 <u>header</u>에 담는다.
   * header와 body는 http header와 http body로 나눌 수도 있고, http body에 들어가는 json 구조로 분리할 수도 있다.

3. API 버전을 관리한다.
   
    * 환경은 항상 변하기 때문에 API의 <u>signature가 변경될 수 있음에 유의</u>해야 한다.
    * 특정 API를 변경할 때는 반드시 <u>하위호환성을 보장</u>해야 한다.

4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.
   
   * 브라우저는 form-data 형식의 submit으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json으로 보내든, 둘 다 form-data 형식으로 보내든 <u>하나로 통일</u>한다.
   * 즉, URI가 플랫폼 중립적이어야 한다.

</br>

### RESTful API 장점

1. Open API를 제공하기 쉽다.
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

</br>

### RESTful API 단점

1. 사용할 수 있는 메소드가 4가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

</br>

### Referencing and Citation
- [REST 아키텍처를 위한 디자인 팁](https://spoqa.github.io/2012/02/27/rest-introduction.html)
- [REST API 제대로 알고 사용하기](https://meetup.toast.com/posts/92)
- [REST API란? 구현 및 사용법](https://www.redhat.com/ko/topics/api/what-is-a-rest-api)
- [REST - 위키백과](https://ko.wikipedia.org/wiki/REST)

---
</br>

## 테스트 주도 개발 (TDD)

### 테스트 주도 개발이란?

테스트 주도 개발(**TDD** : Test-Driven Development)은 <u>매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스</u>이다.   
우선 개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 작성된 코드를 상황에 맞게 리팩토링하는 과정을 거친다.   
이와 같이 <u>테스트가 코드 작성을 주도하는 개발방식</u>을 TDD라고 한다.

</br>

### TDD의 3가지 절차

1. 실패

    첫 번째 절차는 '실패'다. 이는, 실패하는 테스트 케이스를 먼저 만들라는 것이다. 실패하는 테스트 케이스를 만들 때는 프로젝트의 전체 기능에 대하여 처음부터 모든 테스트 케이스를 작성하는 것이 아니라, 지금 가장 먼저 구현할 기능 하나씩 테스트 케이스를 작성한다.

2. 성공

    두 번째 절차는 '성공'이다. 우리가 작성했던 실패하는 테스트 케이스를 통과시키기 위하여, 코드를 작성하여 테스트를 통과시키는 것이다.

3. 리팩토링

    세 번째 절차는 '리팩토링'이다. 우리가 구현한 코드에 중복되는 코드가 있거나, 더 개선시킬 방법이 있다면 리팩토링을 진행한다. 리팩토링을 진행하고 나서도 테스트 케이스가 성공하는지 확인한다. 이 절차가 끝났다면 다시 첫 번째 절차로 돌아가서 다음 기능 구현을 위한 새로운 테스트 케이스를 작성한다.


### TDD 장점

1. 객체 지향적인 코드 개발
   
    테스트 코드를 먼저 작성한다면 좀 더 명확한 기능과 구조를 설계할 수 있다. TDD의 목적인 코드 재사용성을 보장하기 위해 각각의 함수를 정의할 때 각각의 기능들에 대해서 철저히 구조화 시켜 코드를 작성해야 한다.
    즉, TDD는 모든코드가 **재사용성** 기반으로 작성되어야 하기 때문에 기본적으로 객체 지향적인 코드가 된다.

2. 설계 수정 시간의 단축

    테스트 코드를 먼저 작성하므로 최초 설계안을 만족시키며 입출력 구조와 기능의 정의를 명확히 하게 되므로 설계의 구조적 문제를 바로 찾을 수 있다. 기능 구현에 대한 예외 상황들을 미리 확인하므로 예외 코드 작성이 쉽다.

3. 디버깅 시간의 단축

    문제가 발생하였을 때 **단위 테스트** 기반의 테스트 코드로 각각의 모듈 별로 테스트를 진행하여 문제를 쉽게 찾아낼 수 있다.

4. 유지 보수의 용이성

    기존 개발의 경우 코드 작성 시 기술적인 관점으로 바라보기 때문에 코드가 복잡해지고 테스트가 어렵다. 하지만 TDD 개발은 테스트 요소들이 **사용자 관점**으로 정의되고 진행되기 때문에 구조의 변경 및 소수 수정 시 구조를 쉽게 파악하고 빠른 수정이 가능하다.

5. 테스트 문서의 대체 가능

    기존 개발의 경우 테스트를 진행하는 것은 단순 통합 테스트에 지나지 않다. 즉, 내부적으로 개별적인 모듈들이 어떻게 테스트 되었는지 제공하지 않는다. TDD 개발의 경우 테스팅을 자동화 시킴과 동시에 보다 정확한 테스트 근거를 산출할 수 있다.

</br>

### TDD를 활용하기 어려운 이유

1. 개발 시간이 증가한다.

    테스트 코드를 작성하기 때문에 코드량이 늘어난다. 코드량이 늘어난다는 것은 결국 시간이 증가함을 뜻한다. 개발자의 제한적인 시간의 부족으로 인해 테스트 코드를 작성하기 어려워진다. 또한 코드 퀄리티보다는 빠른 생산성이 요구되는 프로젝트의 경우 TDD를 사용하기 적절하지 않다.

2. TDD가 어렵다.

    TDD를 활용한 개발방식에 진입장벽이 있다. 또한 어떤 부분을/어떻게 테스트 해야할지 등 많은 것을 생각해야 한다. 이제까지 자신이 개발하던 방식을 많이 바꿔야 하기 때문에 언러닝(Unlearning : 이미 배운것을 까먹는 과정)을 거쳐야 하기 때문에 어렵게 느껴질 수 밖에 없다.

3. TDD에 대한 이미지/틀 때문에 접근하기 힘들다.

    "반드시 툴(단위 테스트 프레임워크)을 써서 이렇게 해야된다."라고 생각한다. 하지만 이런 규칙에 얽매이는 것은 애자일 방식이 아니다. 하지만 결국 규칙에 얽매여 모든 부분을 확인하고자 똑같은 테스트를 copy&paste 한다. 너무 도구/규칙에 집착하여 TDD가 어려워진다.

</br>

### TDD를 위한 올바른 사용 습관

1. Top-Down으로 방향을 잡고, Bottom-Up으로 구현에 집중하자.

    Top-Down 방식으로 설계 및 시나리오를 잡고, Bottom-Up으로 기능에 대한 코드 구현을 구체화시키면서 문제를 차례차례 해결해나간다.   
    <u>디자인은 Top-Down으로, 기능은 Bottom-Up으로</u>

2. 바보 단계 거치기.

    중간 과정에서의 바보같은 코드를 부끄러워 할 필요가 없다. 오히려 처음부터 완벽한 코드를 작성하려고 한다면 개발 속도에도 저하가 발생하며 개발자의 정신건강에도 좋지 않다. 일단 클라이언트 관점에서 기대하는 바를 충족시킬 수 있도록 빠르게 구현한 후, 테스트 케이스가 깨지지 않는지 확인하며 리팩토링 해나간다.

3. 시나리오 구상하기.

    Given/When/Then 템플릿을 통해 기대 행위에 대한 명세화에 초점을 맞춘다. 기대 행위에 초점을 맞춰서 생각하면 테스트 메소드 각각의 시나리오를 작성하는 것이 한결 수월해진다.

4. TDD의 단위 테스트를 문서화하자.

    코드에 구구절절 기록되어 있는 문서(주석 등)는 시간이 지나면서 신뢰성을 잃을 가능성이 높다. 하지만, 테스트 코드는 거의 최신을 유지할 가능성이 높으며 테스트 코드 자체가 메소드에 대한 사용법이나 예외 등을 담고 있으므로 좋은 샘플 코드로서도 가치가 있다.   
    테스트 코드가 종이 문서보다 좋은 점은 두 가지인데, 하나는 일반적으로 테스트 코드는 메소드 당 작성되기 때문에 해당 메소드에 대한 예외 상황을 파악하기 쉽다는 것이다. 그리고 또 하나는 다른 구현체와의 의존성을 쉽게 파악할 수 있다는 것이다. Given/When/Then 구조의 코드를 통해 테스트 코드를 읽는 것만으로 별다른 노력없이 의존성이 파악되는 경우가 많다.

</br>

### Referencing and Citation
- [테스트 주도 개발 - 위키백과](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C)
- [TDD(테스트 주도 개발)란?](https://gmlwjd9405.github.io/2018/06/03/agile-tdd.html)
- [TDD에 대한 오해와 진실](http://cloudrain21.com/test-driven-development)
- [TDD의 소개](https://velog.io/@velopert/TDD%EC%9D%98-%EC%86%8C%EA%B0%9C)

---
</br>